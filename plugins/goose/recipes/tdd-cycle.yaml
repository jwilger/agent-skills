version: "2.1.1"
title: "TDD Cycle: {{ feature_name }}"
description: >-
  Red/domain/green/domain TDD cycle for implementing a feature using strict
  phase boundaries and domain modeling review checkpoints.

instructions: |
  You are following the red/domain/green/domain TDD cycle. Each feature is
  built through four repeating steps with strict file ownership boundaries.

  THE CYCLE (repeat for each behavior):

  1. RED — Write ONE failing test with ONE assertion. Edit only test files
     (*_test.*, *.test.*, tests/, spec/). Run the test. Paste the failure
     output. Stop and report.

  2. DOMAIN REVIEW (after red) — Review the test for primitive obsession
     and invalid state risks. Create type definitions with stub bodies
     (unimplemented!(), todo!(), raise NotImplementedError). Do not write
     implementation logic. Stop and report.

  3. GREEN — Write the minimal code to make the test pass. Edit only
     production files (src/, lib/, app/). Run the test. Paste the passing
     output. Stop and report.

  4. DOMAIN REVIEW (after green) — Review the implementation for domain
     violations: anemic models, leaked validation, primitive obsession.
     If violations found, state the issue and propose a fix. If clean,
     proceed to COMMIT.

  5. COMMIT — Mandatory. Run the full test suite to confirm all tests
     pass. Stage all changes and create a git commit with a message
     referencing the current scenario. No new RED phase may begin until
     this commit is made. Refactoring, if warranted, happens in a
     separate commit after this one.

  After step 5, start the next test.

  PHASE BOUNDARIES:
  - RED: only test files
  - DOMAIN: only type definitions (structs, enums, interfaces, traits)
  - GREEN: only implementation bodies

  If blocked by a boundary, stop and ask the user rather than crossing it.

  EVIDENCE REQUIRED: Always run tests and paste the actual output. Never
  say "I expect it to fail/pass" — show the evidence.

  DOMAIN MODELING: Use domain types, not primitives. Email not String,
  Money not float. Parse at the boundary, trust types internally. Make
  invalid states unrepresentable. If you see primitive obsession in a test
  or implementation, flag it and propose the domain type.

prompt: |
  Implement {{ feature_name }} using the TDD cycle.

  {{ acceptance_criteria }}

  Start with the first acceptance criterion. Write one failing test, then
  follow the red/domain/green/domain cycle for each behavior.

parameters:
  - key: feature_name
    input_type: string
    requirement: required
    description: "Name of the feature to implement"
  - key: acceptance_criteria
    input_type: string
    requirement: required
    description: "Acceptance criteria for the feature (Given/When/Then preferred)"

extensions:
  - type: builtin
    name: developer
    display_name: Developer
    timeout: 300
    bundled: true

activities:
  - "Write a failing test for the first acceptance criterion"
  - "Review test for domain modeling quality"
  - "Implement minimal code to make the test pass"
  - "Review implementation for domain violations"
  - "Run full test suite and commit with scenario reference"
